"""
rat_command.py - Handles Command registration and Command-triggering IRC events

Copyright (c) 2018 The Fuel Rats Mischief,
All rights reserved.

Licensed under the BSD 3-Clause License.

See LICENSE.md

This module is built on top of the Pydle system.

"""

from functools import wraps
import logging

import re

from Modules.trigger import Trigger
import config

# set the logger for handlers

log = logging.getLogger(f'{config.Logging.base_logger}.handlers')


class CommandException(Exception):
    """
    base Command Exception
    """
    pass


class InvalidCommandException(CommandException):
    """
    invoked command failed validation
    """
    pass


class CommandNotFoundException(CommandException):
    """
    Command not found.
    """
    pass


class NameCollisionException(CommandException):
    """
    Someone attempted to register a command already registered.
    """
    pass


class _Command:
    """
    Command object, to only be generated by `Commands.command()` decorator
    """
    pass


class Commands:
    """
    Handles command registration and execution
    """

    ####
    # logger facility
    log = logging.getLogger(f"{config.Logging.base_logger}.commands")
    ####
    # commands registered with @command will populate this dict
    _registered_commands = {}
    _rules = {}

    ####
    # character/s that must prefix a message for it to be parsed as a command.
    prefix = '!'

    ####
    # Pydle bot instance. #FIXME set value during MechaClient init!
    bot = None

    @classmethod
    async def trigger(cls, message: str, sender: str, channel: str):
        """
        Invoke a command, passing args and kwargs to the called function
        :param message: triggers message to invoke
        :param sender: author of triggering message
        :param channel: channel of triggering message
        :return: bool command
        """
        log.debug("trigger called!")
        if cls._registered_commands is None:
            cls.log.critical(
                " registered commands dict somehow was set to None")
            raise CommandException("registered_commands is None!")
        if not cls.bot:
            # someone didn't set me.
            raise CommandException(f"cls.bot is not set. (value = {cls.bot}")

        cls.log.debug(f"triggered! message is {message}")

        if not message:
            raise InvalidCommandException(f"Command required, got {message}")
        elif not message.startswith(cls.prefix):
            log.debug(f"ignoring message{message} as it does not start with "
                      f"my prefix.")
            return None
        else:
            # remove command prefix
            raw_command: str = message.lstrip(cls.prefix)

            words = []
            words_eol = []
            remaining = raw_command
            while True:
                words_eol.append(remaining)
                try:
                    word, remaining = remaining.split(maxsplit=1)
                except ValueError:
                    # we couldn't split -> only one word left
                    words.append(remaining)
                    break
                else:
                    words.append(word)

            trigger = Trigger.from_bot_user(cls.bot, sender, channel, words, words_eol)

            if words[0] in cls._registered_commands.keys():
                cmd = cls._registered_commands[words[0]]
            else:
                for key, value in cls._rules.items():
                    if key.match(words[0]) is not None:
                        cmd = value
                        break;
                else:
                    raise CommandNotFoundException(f"Unable to find command {words[0]}")

            return await cmd(cls.bot, trigger, words, words_eol)

    @classmethod
    def _register(cls, func, names: list or str) -> bool:
        """
        Register a new command
        :param func: function
        :param names: names to register
        :return: success
        """
        if isinstance(names, str):
            names = [names]  # idiot proofing

        if func is None or not callable(func):
            # command not callable
            return False

        else:
            for alias in names:
                if alias in cls._registered_commands:
                    # command already registered
                    raise NameCollisionException(f"attempted to re-register"
                                                 f" command(s) {alias}")
                else:
                    formed_dict = {alias: func}
                    cls._registered_commands.update(formed_dict)

            return True

    @classmethod
    def _flush(cls)->None:
        """
        Flushes registered commands
        Probably useless outside testing...
        :return: None
        """
        cls._registered_commands = {}

    @classmethod
    def command(cls, *aliases):
        def real_decorator(func):
            @wraps(func)
            async def wrapper(bot, trigger, words, words_eol):
                cls.log.debug("inside wrapper")
                try:
                    # This works if we're the bottommost decorator (calling the command function
                    # directly)
                    return await func(bot, trigger)
                except TypeError:
                    # Otherwise, we're giving all the things to the underlying wrapper (be it from
                    # parametrize or sth)
                    return await func(bot, trigger, words, words_eol)

            # we want to register the wrapper, not the underlying function
            cls.log.debug(f"registering command with aliases: {aliases}...")
            if not cls._register(wrapper, aliases):
                raise InvalidCommandException("unable to register commands.")
            cls.log.debug(f"Success! done registering commands {aliases}!")

            return wrapper
        return real_decorator

    @classmethod
    def rule(cls, regex: str):
        def decorator(coro):
            async def wrapper(bot, trigger, words, words_eol):
                try:
                    return await coro(bot, trigger)
                except TypeError:
                    return await coro(bot, trigger, words, words_eol)

            cls._rules[re.compile(regex, re.IGNORECASE)] = wrapper
            log.info(f"New rule matching '{regex}'.")
            return wrapper
        return decorator

    @classmethod
    def get_command(cls, name: str):
        # remove the prefix.
        name = name.strip(cls.prefix)
        # see if its a command
        if name in cls._registered_commands:
            cls.log.debug("command found!")
            return cls._registered_commands[name]
        else:
            return None
